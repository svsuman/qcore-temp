const fs = require('fs');
const harnessMapping = require('./harnessMapping.js');
const aws = require('./aws.js');
const enginesFinder = require('./engines.js');

let SecretsManager
const loadedValues = {};

const evalExpression = async function(secretsManager, evalString, context) {
  SecretsManager = secretsManager;


  const AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
  const asyncFunc = AsyncFunction(`
    try {
      return await this.${evalString};
    } catch (error) {
      console.warn("Bad PSL key, you must use :");
      console.warn(" * secrets.getValue\(\'org.HARNESSNAME-awsdev\'\) to get value using harness format");
      console.warn(" * aws.getValue\(\'/AWS/SECRET_MANAGER/PATH#AWS_KEY\'\) to get value using direclty the aws-cli");
      throw error;
    }`);

  const boundAsyncFunc = asyncFunc.bind(context);
  return await boundAsyncFunc();
}

const bulkLoadValues = async function(SecretsManager, content, skipcache, engine) {
  let pendingHarnessKeys = [];
  let pendingAwsSecretKeys = [];

  const getHarnessKey = async function (harnessVariableName) {
    // for harness nextgen, it seems like they use "org." namespace in their delegator, but not supported
    // by their APIs, so we need to remove this useless namespace :'D
    const key = harnessVariableName.replace(/^org\./, '')
    pendingHarnessKeys.push(key);
    return key;
  };

  const getAwsKey = async function (secretValuePath) {
    pendingAwsSecretKeys.push(secretValuePath);
    return secretValuePath
  };

  const evalExpressionContext = {
    // mocking the secrets.getValue feature to simply register the secret key in our pendingHarnessKeys array.
    secrets: {
      getValue: getHarnessKey,
      getEscapedValue: getHarnessKey,
    },
    aws: {
      getValue: getAwsKey,
      getEscapedValue: getAwsKey,
    }
  }

  const regex = await enginesFinder.getEngineRegex(engine);
  let result = content.toString();
  let m;

  // Get all secret key names from input file
  while ((m = regex.exec(result)) !== null) {
    const all = m[0];
    const prop = m[1] || m[2];

    const value = await evalExpression(SecretsManager, prop, evalExpressionContext);
    result = result.replace(all, 'dummy'); // To be able to jump to the nex occurence (tricks to loop in regexp)
  }

  if ( pendingHarnessKeys.length > 0 ) {
    // Bulk load mapping from Harness
    const secretManagerMappings = await harnessMapping.secretManagerKeysFromHarness(pendingHarnessKeys, skipcache);

    // Load SecretManager values using harness mappings
    for (const key of Object.keys(secretManagerMappings)) {
      if (secretManagerMappings[key]) {
        const v = await aws.getSecretManagerValue(SecretsManager, secretManagerMappings[key]);
        loadedValues[key] = v;
      }
    }
  }

  for (const key of pendingAwsSecretKeys) {
    try {
      const v = await aws.getSecretManagerValue(SecretsManager, key);
      loadedValues[key] = v;
    } catch {}
  }
}

const replaceValues = async function(SecretsManager, content, engine) {
  const getValue = async function(variableName) {
    // for harness nextgen, it seems like they use "org." namespace in their delegator, but not supported
    // by their APIs, so we need to remove this useless namespace :'D
    const key = variableName.replace(/^org\./, '')

    return loadedValues[key] || 'UNKNOWN_VARIABLE_KEY';
  };

  const getEscapedValue = async function(variableName) {
    const value = await getValue(variableName);
    return value.replace(/\$/g, '\\$');
  };

  const evalExpressionContext = {
    secrets: { getValue: getValue, getEscapedValue: getEscapedValue },
    aws:     { getValue: getValue, getEscapedValue: getEscapedValue }
  }

  const regex = await enginesFinder.getEngineRegex(engine);

  let result = content.toString();
  let m;

  while ((m = regex.exec(result)) !== null) {
    const all = m[0];
    const prop = m[1] || m[2];

    const value = await evalExpression(SecretsManager, prop, evalExpressionContext);
    result = result.replace(all, value);
  }
  return result;
}

const parse = async function(SecretsManager, content, skipcache, engine) {
  // bulk load secrets
  await bulkLoadValues(SecretsManager, content, skipcache, engine)
  const result = await replaceValues(SecretsManager, content, engine)

  return result;
}

exports.renderFile = async function(SecretsManager, filePath, skipcache = false, engine = 'dollar') {
  const fileContent = fs.readFileSync(filePath);

  const output = await parse(SecretsManager, fileContent, skipcache, engine);
  console.log(output.toString())
}
